# INTRODUCTION  

**章节生词**  
term-术语  Imposing-加强  inherited-遗传/派生  shaded-阴影  portable-便携的  optimized-优化  machinery-机械地  matrices-矩阵  intermediate-中间的
realistic-逼真  touched on-涉及  imagery-意象  ubiquitous-无处不在  sensory-感觉   subtle-微妙    robust-强壮地 interactivity -交互性  
informative-信息丰富  Historically-历史上看  immerse-沉浸  Visualization-可视化  foreseeable-可预见的 heuristic-启发  hypothesize-假设  
three-dimensional三维   range-finding-测距  endeavor-行业 reasonable-合理的  sophisticated-复杂的  tradeoffs-权衡  substitute-替代
synthetic-合成  foregrounds-前景   dataset-数据集  extract-提炼  bottlenecks-瓶颈 salient-突出的  coordinate frames-坐标系
inevitably-不可避免的  depiction-描述  dominant-主流的  paradigms-范式  integrated-集成  orthonormal-正交  ownside-缺点  
terminology-术语  locality-位置 Examine-检查  reveals-发现 upfront-前期 merit-优点 intervals-间隔 precision-精确  deterministic-确定性的

  **计算机图形学**这一术语描述任何用于使用计算机对图像的创建和加工.这本书介绍如何使用算法和数学工具来生成各种的图像-包括逼真的视觉特效，信息丰富的技术类图形，或者漂亮的计算机动画等.图形有二维或者三维；图像可以是完全合成的，也可以是通过处理照片而产生的，这本书就是介绍基本的算法和数学，特别是被用于生成三维物体或者场景中的合成图片.   
  实际上要做计算机图形方面的工作不可避免的要知道一些特殊的硬件，文件格式，以及通常一个或两个图像API，计算机图形学是一个快速发展的领域，所以要学的东西也是不断变化的，因此，在这本书中我们尽最大努力不用特殊的硬件或者API.鼓励读者根据自己的软件和硬件环境补充文本相关文档.幸运的是计算机图形学已经有足够多去能够去很好的映射绝大多的环境的描述标准术语和概念  
  这章节定义了一些基本的术语，提供一些历史背景，以及有关计算机图形的信息起源.   
    
  ## 1-1图形领域  
  在任何领域加强分类是比较危险的，而大多数的图形学从业者都会遵循如下的主要领域  
    ·**建模**是处理存储能够存储在计算机上的形状和外观属性的数学规范.比如一个咖啡杯可以被描述为有序的三维坐标点以及一些插值规则去连接这些点以及能够描述光怎么去和这个杯子交互的反射模型  
    ·**渲染**一词是派生于艺术，他是用来处理3D计算模型的阴影图片的创建  
    ·**动画**是一种通过有序列的图片创建天马行空的动作的技术，动画使用建模和渲染但是添加了随时间而运动的关键问题，这些问题通常不是简单的处理建模和渲染  
  还有很多和计算机图形学相关的概念，他们是否是关键的图形领域知识选择问题.本文至少会涉及到这些内容,这样的领域包括如下:  
    ·**用户界面**处理介于输入设备（鼠标/键盘），应用，用户的意象反馈和其他的感觉反馈的界面，历史上看，这个领域和图形学紧密相关是因为图形学的研究人员有一些提前的路径去输入输出设备，目前也是无处不在的  
    ·**VR**试图让用户沉浸到3D世界，这个通常的要求是至少有环绕声、图像和能根据头方向给出回应，真正的VR来说，声音、力反馈都是需要提供的，因为这个领域需要先进的3D图像和先进的展示科技，所以和图像密不可分  
    ·**可视化**通过虚拟展示给用户提供一个视角去看理解的信息，通常这里都有一些图形学的问题  
    ·**图像处理**是操作2D图片，这被用在图形学和视觉两个领域  
    ·**3D扫描**使用测距技术去创建测量的3D模型，此类模型对于创建丰富的视觉图像是非常有用的，并且这个过程通常都需要图形学算法  
    ·**计算摄影**是利用计算机图形学、计算机视觉和图像处理方法来实现以新的方式捕捉物体、场景和环境。  
    
  ## 1-2主要应用  
  几乎任何行业都可以利用计算机图形学，但计算机图形技术的主要消费者包括以下行业：  
    ·**电子游戏**使用复杂的3D模型和渲染算法  
    ·**动画片**通常都是通过3D模型直接渲染.许多传统的2D动画使用背景渲染都是来自3D渲染，这使得视角不断移动，而不需要大量花费艺术家的时间  
    ·**视觉特效**几乎使用了各种类型的图形学技术，几乎所有的现代影片都会使用数字合成技术将背景和单独拍摄融合在一起，很多电影同样会使用3D模型和动画去创建合成的环境，物体，甚至能创建让观众无法辨认真伪的角色  
    ·**动漫电影**使用使用了很多和视觉特效一样的技术，但是不追求逼真的图像  
    ·**CAD/CAM**使用计算机技术去设计和生产，然后使用这些虚拟设计指导生产过程，比如许多机械零件都是在 3D 计算机建模程序中设计的，然后在计算机控制的铣削设备上自动生产  
    ·**仿真**可以被认为是更精确的电子游戏.比如飞行模拟使用复杂的3D图形去模拟飞行，这种模拟对于安全关键领域（例如驾驶）的初始训练以及经验丰富的用户的情景训练（例如特定的消防情况，这些情况在物理上过于昂贵或危险）非常有用  
    ·**医疗成像**创建有意义的扫描数据图像，比如CT数据集是由大量的3D密度值矩阵行列.计算机图形被用作创建阴影图片去帮助医生提炼最重要的信息  
    ·**信息可视化**创建的图像没有必要的所谓自然的视觉描述，比如十只不同股票的价格的时间趋势并没有明显的视觉描述，但巧妙的绘图技术可以帮助人类看到此类数据中的模式  

  ## 1-3图形API  
  使用图形库的一个很重要的部分就是处理图形API，应用程序接口 (API) 是一组用于执行一组相关操作的标准函数集合，而图形 API 是一组用于执行基本操作（例如在屏幕上的窗口中绘制图像和 3D 表面）的函数.  
    每一个图形程序需要能够使用两个相关的API:一个是用于视觉输出，一个是能够从用户获取输入的用户界面API，目前，图形和用户界面 API 有两种主流范式，第一个是方法集成，拿Java为例，它的图形和用户界面的工具是集成可移植的，已经完全标准化并作为语言的一部分受到而支持.第二种的代表就是Direct3D和OpenGL，他们的画图命令是软件库的一部分并紧密的和语言连接，比如C++，而用户界面软件是一个独立的实体，可能因系统而异  
    不管选择哪种API，基本的图形命令大部分都是相同的，这本书基本都会用到  
      
  ## 1-4图形管线  
  现在每台电脑都有非常强大的图形管线.这是一种特殊的软件/硬件集成系统，能够高效的绘制3D图元，通常这些系统针对处理具有共享顶点的3D三角形进行了优化.管线上的基本操作映射3D顶点到2D屏幕位置，并对三角形上色让他们看起来真实并且以正确的从后到前的位置出现  
  尽管以正确的由后到前的顺序绘制三角形曾一度是计算机图形学研究的最重要的问题，但是现在基本被z-buffer解决了，它使用了特殊的内存缓冲使用蛮力去解决了这个问题  
  它证明了图形管线中的几何操作能够被三个传统几何坐标和有助于透视观察的第四个齐次坐标组成的 4D 坐标空间中完成，这些4D坐标使用了4×4矩阵和4维向量.所以图形管道包含许多用于高效处理和组合此类矩阵和矢量的机制，这个4D坐标系统是最计算机图形学中微妙和漂亮的结构之一，并且它毫无疑问是学习图形学最大的障碍  
  图像生成的速度取决于绘制三角形的数量.因为在许多应用中交互性有时候比视觉质量更重要，所以降低三角形的数量就是很有意义的，除此之外，距离也是影响三角形数量的关键因素，这表明用不同的细节层次（LOD，Level of ditail）来表示模型是有用的  
    
  ## 1-5数值问题  
  很多图形学问题真的只是3D数值代码.数值问题常常是至关重要的，在过去，以稳健且可移植的方式处理此类问题非常困难，因为机器对数字有不同的内部表示，更糟糕的是，以不同且不兼容的方式处理异常，幸运的是几乎所有现代计算机都遵循IEEE标准，这使得程序员可以对如何处理某些数字条件做出许多方便的假设  
  首先，最重要的是去了解如下三个特殊值：  
  1:正无穷 2：负无穷 3：非法数(NaN),特别的是需要记住如下规则，对于任意正数a：  
  **+a/(+00) = +0， -a/(+00) = -a, +a/(-00) = -0, -a/(-00) = +0.**  
  **00 + 00 = + 00, 00 - 00 = NaN , 00×00 = 00, 00/ 00 = NaN, 00/a = 00, 00/0 = 00, 0/0 = NaN**  
  **+a/ +0 = +00,-a/+0 = -00**  
  任何包含NaN的结果都是NaN，任何包含NaN的布尔值都是false  

   ## 1-6效率  
   没有什么魔法规则能够让编码变得很有效率.效率是通过认真的权衡来完成，这些权衡对于不同的结构是不一样的.但是对于可预见的未来，一个好的启发是程序员应该放更多注意力在内存访问模式而不是操作计数，这与二十年前最好的启发式方法正好相反，这种转变的发生是因为内存速度没有跟上处理器的速度。由于这种趋势持续下去，有限且一致的内存访问对于优化的重要性只会增加  
   一个写代码更快的合理方法是遵循如下步骤：  
   1：尽可能以最直接的方式来编写代码，根据需要动态计算中间结果而不是存储它们  
   2：以优化模式进行编译  
   3：使用任何现有的分析工具来查找关键瓶颈   
   4：检查数据结构以使数据单元大小与目标架构上的缓存/页面大小相匹配  
   5：如果分析发现数值计算存在瓶颈，请检查编译器生成的汇编代码，以查找效率缺失。重写源代码以解决您发现的任何问题  
   这里面最重要的是第一点.大对数的优化都会使得代码变得难以阅读.除此之外，前期花在优化代码上的时间通常比花在修正错误或添加功能上的时间要好，同时要留意来自之前的文本的建议;一些经典的技巧，比如使用整数int代替实数来提高速度，因为现代 CPU 通常可以以与执行整数运算一样快的速度执行浮点运算，但是在所有的情况下，需要进行分析以确保针对特定机器和编译器的任何优化的优点  

   ## 1-7设计/编写图形代码  
   提供一些编写的建议，会对你学习有帮助  
     
   ### 1.7.1类设计
    
   所有的图形程序都有一个关键的部分就是拥有针对几何实体（例如矢量和矩阵）以及图形实体（例如 RGB 颜色和图像）的良好类或例程.这些管理应该尽可能简洁高效.一个通用的设计问题是，位置和位移是否应该作为单独的类，因为它们具有不同的操作；比如位置乘以1/2没有几何意义，而位移的一半有几何意义，在这个问题上几乎没有达成一致，这可能会引发图形从业者数小时的激烈争论，但为了举例说明，我们假设我们不会做出区分，这意味着要编写的一些基本类包括：  
   · vector2 一个存储x和y的2D向量类，它应该将这些分量存储在长度为 2 的数组中，以便能够很好地支持索引运算符，此外还应该包括矢量加法、矢量减法、点积、叉积、标量乘法和标量除法的运算.  
   · vector3 一个类似二维向量类的三维向量  
   · hector  一个四维向量  
   · rgb      一个存储三个成分的RGB颜色，还应该包括 RGB 加法、RGB 减法、RGB 乘法、标量乘法和标量除法的运算.  
   · 变换     一个为了变换的4×4矩阵，应该包含矩阵乘法和成员函数，以应用于位置、方向和表面法向量
   · 图像     一个包含输出操作的RGB像素的二维数组
    此外，可能想要或不想添加区间、正交基和坐标框架的类

   ### 1.7.2浮点数/双精度double
   现代的结构表明降低内存使用率和维持一致的内存访问是提高效率的关键，这建议使用精确的数据.然而避免数值问题表明使用双精度算数.权衡取决于程序，但最好在类定义中有一个默认值.

   ### 1.7.1调试图形程序
   如果你有了解你就会发现现在的程序员变得越来越有经验，他们现在很少使用传统的调试工具了.一个原因是相比于简单程序，使用传统的调试工具对于复杂的程序变得更加尴尬了.另一个原因是大多数的难搞的错误是概念性的错误，即执行了错误的事情，很容易浪费大量时间，逐行检查变量值而没有发现这种情况，有几种调试策略在图形处理中特别有用
   · **科学的方法**
   在图形程序中，有一种替代传统调试的方法，通常非常有用.它的缺点是，它与计算机程序员在职业生涯早期被教导不要做的事情非常相似，所以如果你这样做，你可能会觉得“不听话”：我们创建一个图像，然后观察它有什么问题.然后我们展开一个假设关于他是什么原因造成的并且测试他.比如，在光线追踪程序中，我们可能会看到许多看起来随机的暗像素，这是大多数人在编写光线追踪器时遇到的经典“阴影痤疮”问题，传统的调试器在这里就没用了，所以我们必须意识到，阴影光线正在照着被遮蔽的表面.我们可能会注意到黑点的颜色是
环境色，所以缺少的是直接照明.直接光能在阴影中关闭，直接照明可以在阴影中关闭，因此可能会假设这些点被错误地标记为处于阴影中，但实际上并非如此，为了验证这个假设，我们可以关闭阴影检查并重新编译，这表明这些是错误的阴影测试，我们可以继续我们的检查.这种方法有时能起到很好作用的关键原因是我们从来不需要发现错误的值或者真正确定我们的概念错误.相反，我们只是通过实验缩小了概念错误的范围。通常，只需要几次试验就能找到问题所在，这种调试方式非常有趣.  
  
   · **图像作为编码调试输出**  
   在许多情况下，从图形程序中获取调试信息的最简单渠道是输出图像本身,如果你想知道每个像素计算部分变量的值，你能够临时修正你的程序以将该值直接复制到输出图像并跳过通常会进行的其余计算，比如怀疑表面法线的问题导致了阴影问题，则可以将法线向量直接复制到图像中（x 变为红色，y 变为绿色，z 变为蓝色），从而得到实际在计算中使用的向量的颜色编码图示.或者你怀疑一个特定值越界，让你的程序在发生这种情况的地方写入鲜红色的像素.其他常见技巧包括用明显的颜色绘制表面的背面（当它们不应该可见时），根据对象的 ID 号为图像着色，或根据计算所需的工作量为像素着色  
  
   · **使用调试器**
   仍然存在一些情况，特别是当科学方法似乎导致了矛盾时，当没有其他方法可以替代观察到底发生了什么时。问题在于图形程序通常涉及许多相同代码的执行（例如，每个像素一次，或每个三角形一次），这使得从一开始就在调试器中逐步执行变得完全不切实际。而且最困难的错误通常只发生在复杂的输入中.一种有用的方法是为错误“设置陷阱”。首先，确保您的程序是确定性的——在单个线程中运行它，并确保所有随机数都是固定计算出来的。然后，找出哪个像素或三角形是错误，并在您怀疑不正确的代码之前添加一条语句，该语句将仅在可疑情况下执行。例如，如果您发现像素 (126, 247) 出现错误，则添加if x = 126 and y = 247 then print “blarg!”  
   在程序崩溃的情况下，传统的调试器可用于精确定位崩溃的位置。然后，您应该开始在程序中回溯，使用断言和重新编译，以查找程序出错的位置。这些断言应该留在程序中，以防您将来添加的潜在错误。这再次意味着避免了传统的逐步过程，因为那不会为您的程序添加有价值的断言.

   · **用于调试的数据可视化**
   通常你想知道你的程序在做什么是比较难的，因为它在出错前会计算出很多中间结果.这种情况是和科学实验计算出很多数据是很相似的，一个解决方案也是一样的，制作好的图表和插图可以帮助你理解数据的含义，在光线追踪器中，您可以编写代码来可视化光线树，这样您就可以看到哪些路径对像素有贡献，或者在图像重采样例程中，您可以绘制图表来显示从输入中获取样本的所有点.花费时间编写代码来可视化程序的内部状态，也会在优化程序时更好地理解其行为.
